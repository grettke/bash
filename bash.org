* Making Sense of this Script
:PROPERTIES:
:ID:       886036D5-3715-492B-9ABF-825F4058A995
:END:

** Desires
:PROPERTIES:
:ID:       C1CA8CCE-D299-4034-8ACA-432622B38640
:END:

- Things that I want to do with Bash, and how I want to do them
  - Understand the computer and its operating system
    - Explore the contents of the disk drive and memory
  - Automated tedious and error prone tasks as quickly as possible
    - Develop shell scripts to do so
    - Leverage multi-tasking
  - Maximize expressivity and predictability
    - Maximize predictability
    - Minimize surprise
    - Fail fast

** Approach to Learning and Configuring Bash

- Bash provides a rich and complicated configuration facility
- Successfully solving problems with Bash requires that you (goal)
  - Understand what it can do
  - Configure it to do so in a way that you prefer
- Working with Bash provides the results by recognizing that you attain practice
  and experience (means)
  - Understanding possibilities requires study and practice (practice)
  - Configuring requires experience and personal-preference (experience)
- The purpose of this document is to capture both the means and the goal

** The Purpose of Bash

- The ~set~ builtin
  [fn:1c25a9a2ecf21a00:https://www.gnu.org/software/bash/manual/html_node/The-Set-Builtin.html]
  onerously states that "This builtin is so complicated that it deserves its own
  section". That can be off-putting for the new-operator (or programmer). The
  word /complicated/ is more like a code-word here though; it is really a short
  hand for /expressivity/. ~set~ lets you configure the system (Bash) any way you
  choose; it fully enables you to express your personal definition of
  expressivity when it comes to system management. This is no small feat. Doing
  so belies the complexity, magnitude, and power lurking behind the thin veneer
  that most only know as "the powerful command line interface" that most only
  use to start graphical user interface applications. Bash is the most humble
  servant; expertly negotiation with the kernel, humbly taking orders from the
  operator, and deftly managing the work of any number of processes.
  Forgive my anthropomorphization; we may ever know someone like Bash in our own
  lives for that is truly a rare and kind soul.

** Understanding Your Cognitive Landscape
:PROPERTIES:
:ID:       435374DD-FDEA-4D0A-B5C2-5E205B30B04F
:END:

- Doing things with Bash
  - It is difficult to make sense of all of the configuration options for doing
    things with Bash
  - When you've got experience, rely on that
  - When you haven't got experience, document your intent and obtain experience
  - Both the things that you do with Bash and the thing that you /want to/ do with
    Bash are your personal cognitive landscape that guide the configuration
- Roles of Doers
  - My goal is to classify configuration options by roles that have different
    goals. Some of the roles have overlap in the goals, some don't. I don't
    know yet what are the best role definitions or how options overlap. I will
    find out and document it here. /Doers/ is the name of someone or something
    executing things with an intent. My goal is to reveal intent and use that
    for classification and role definition.
  - Broad Doer definitions
    - Interactive vs Non-Interactive Shell
      - Interactive: requires input from the user
      - Non-Interactive: doesn't
      - Unsure how to use this to classify configuration because most scripts
        are in a =tty= and you /can/ accept input. Should you? Is that the question?
        What does it mean to configure Bash, and for what? Here is an attempt:
        - Interactive is for configuring things that you only ever want to do
          or care about as a human sitting at a terminal. These are things that
          I will pretend/decide that I will never every do when running a
          non-interactive script. This whole plan relies on strictly separating
          implementation of both kinds of scripts
        - Non-interactive is for things that I as a human will never see. Or
          perhaps things that I don't care to see immediately because I didn't
          run them. The overlap is so close here. Perhaps "things that I want
          to see" and "things that I want to do interactively" is the correct
          classifier.
        - This is a design choice
    - Login and Non-Login Shell
      - Are you initiating things or is a ~cron~?
      - This is a system/user choice
        - You choose to use the system; executing things via a Login shell
        - You schedule things for the system to do; executing things via a
          Non-Login shell
- Classifying things Bash can do
  - Not using tags to classify because they won't reflect document structure and
    I'm not sure where to begin
  - Tried using multiple tags and that confused the whole effort
  - Switched to one tag
    - Every time I feel like using multiple tags, I will try to update the
      Desires to make sense of what I value

** Observations & Questions & Decisions

*** Version 1

- The login interactive shell is for things that you will only do at the
  start and finish of a logical session
  - Attached to your ID and a ~tty~ owned by you
  - Not much work to do here
- The login non-interactive shell is for things that you will do every time
  that you begin another shell during a logical session
  - This includes the login interactive shell, execute this as suggested by
    the Bash reference manual
- The non-login non-interactive shell
  - Is non-interactive because you have no way of interacting with it unless
    you hack some way to do so
  - Non-Interactive is somewhat a misnomer here because you can choose to
    implement non-interactive scripts when a ~tty~ is attached but when you
    haven't got a ~tty~ attached there is no possibility of running interactive
    scripts
  - Is non-login because it is not associated with your ID and at the same
    time not attached to a ~tty~ attached to you
  - This document won't address non-login shells
    - If you develop your scripts in a richly configured Bash environment, you
      will have to configure non-login shells to use the same environment. I am
      avoiding this topic because I need to see where this experiment goes.
    - That was a mistake. After developing a powerful Bash environment you are
      likely to want to use that same environment for non-login shells. Of
      course you are!

*** Version 2

- Configure Bash for every user?
  - Login Interactive and Non-Login Interactive are easy and obvious
  - Non-Login Non-Interactive seems valuable but is less obvious
- Bash vs Dash
  - Performance reasons?
  - [[https://www.wikivs.com/wiki/Bash_vs_dash][Via]]
    #+BEGIN_QUOTE
     Dash (Debian Almquist SHell) is a shell that has poor usability by modern standards when used as an interactive log-in shell, but is faster in executing POSIX-compliant scripts than Bash.
     Bash (Bourne Again SHell) has many more features and is especially preferable when used interactively (although it does contain more programming features too).
     Bash is typically provided as the default interactive shell, while Debian and Debian-derivatives like Ubuntu provide Dash as the /bin/sh implementation, thereby causing scripts with #!/bin/sh shebangs to be interpreted by Dash rather than Bash by default. For scripts that require Bash for execution, Bash will still be used as the interpreter if the shebang is #!/bin/bash.
     Bash is designed for human beings and provides a superset of POSIX functionality
     Supports the same scripting commands as Dash as well as its own additional commands (sometimes called "Bashisms")
     Supports tab completion
     Supports a command history
     Dash is for non-interactive script execution
     Only supports POSIX compliant features
     Small binary size (Dash is only 100K compared to Bash's 900K)
     Faster start-up and script execution
     #+END_QUOTE
    - This provokes more questions
      - Why have programming expressivity for DevOps and System Administration
        if you can't or shouldn't use it for startup scripts?
- [[http://lkhill.com/binsh-checking-for-bash-vs-dash-incompatibilities/][Just call Bash explicitly; it is not an issue]]
- [[http://shebang.brandonmintern.com/bourne-is-not-bash-or-read-echo-and-backslash/][Important differences between Bourne and POSIX compliant shells]]
  - POSIX for speed
  - Bash better for scripting
  - Call it for the user with =#!/usr/bin/env bash=
- Bash is for interactive tasks; Dash is for non-interactive tasks
- You don't need Readline in non-interactive mode

*** Version 3

- Desires read like
  - Things that you would do as a software engineer
  - Things that you would do as a devops engineer
- Desire don't read like
  - Things that you would do as scheduled task
  - Things that you would do as a remotely executed task
- This looks like a Bash system that
  - Configures Bash for login shells and nothing more
- Because
  - Any further scope has no desires or experience to guide it
    - Attempting to do anything more would result in aimless fruitless wandering

* Configuration
:PROPERTIES:
:ID:       A1DF7D9E-5B52-46D6-90CB-FC43C50D5E41
:END:

- Bash Startup Behavior [fn:49d34ab293ff88f:https://www.gnu.org/software/bash/manual/html_node/Bash-Startup-Files.html#Bash-Startup-Files]
- Bourne Variables [fn:105ae6c2bd4f43c8:https://www.gnu.org/software/bash/manual/html_node/Bourne-Shell-Variables.html#Bourne-Shell-Variables]
- Bash Variables [fn:7b4f219d43d6ef2:https://www.gnu.org/software/bash/manual/html_node/Bash-Variables.html#Bash-Variables]

** Interactive Non-Login
:PROPERTIES:
:header-args: :tangle ./.bashrc
:ID:       30F7B093-5CC8-4545-A30E-C9D025AC7265
:END:

**** Options
:PROPERTIES:
:ID:       353A8149-9AE8-41A8-878D-22D5141C1AA9
:END:

***** Set
:PROPERTIES:
:ID:       304CD69B-9D22-4E27-8566-2223E340AF37
:END:

- Environment
  - Child shells inherit *every* function and variable created or modified
    #+NAME: ACD7221D-802A-4999-AF10-E0E43E98DB17
    #+BEGIN_SRC shell bash
set -o allexport
    #+END_SRC
- Evaluation
  - Perform brace expansion
    #+NAME: 159E2F76-E2E4-4D77-869C-9B1173E10036
    #+BEGIN_SRC shell bash
set -o braceexpand
    #+END_SRC

***** Shopt
:PROPERTIES:
:ID:       A6298426-7595-4D20-8214-FF28A0534F9F
:END:

**** Variables
:PROPERTIES:
:ID:       3773C1C1-F98E-4B95-8067-715796A83686
:END:

Provide just enough information at the prompt to be useful without cluttering
up the terminal. Escaping not required.

#+NAME: 2EF3117A-BB20-475A-9970-14C361F3687F
#+BEGIN_SRC shell bash
PS1='\u@\h:\w> '
#+END_SRC

Make the continued prompt obvious. Escaping not required.

#+NAME: 07689AC5-8AC7-4B3E-88ED-BC7CA747BB35
#+BEGIN_SRC shell bash
PS2='↪> '
#+END_SRC

**** Functions
:PROPERTIES:
:ID:       C61DCCE0-1782-4511-BA40-E84B8A12C566
:END:

** Interactive Login
:PROPERTIES:
:ID:       2476DE76-A6CB-4834-9DEA-6A644BED0F54
:END:

*** Login
:PROPERTIES:
:header-args: :tangle ./.bash_profile
:ID:       B281581F-2E1B-4E02-9787-BE9E23DD8907
:END:

Execute the same configuration as every non-login interactive shell.

#+NAME: 5487397C-D5F5-4C24-919C-66BFAF9B9312
#+BEGIN_SRC shell bash
if [ -f ~/.bashrc ]; then . ~/.bashrc; fi
#+END_SRC

Have fun.

#+NAME: 04A53A3A-B30D-4122-8736-6F411639FE61
#+BEGIN_SRC shell bash
fortune
#+END_SRC

*** Logout
:PROPERTIES:
:header-args: :tangle ./.bash_logout
:ID:       D0503846-C5ED-4CBC-99F3-2B3DE5449FC3
:END:

Have fun.

#+NAME: E55BD1DC-42CF-4394-B2C1-5D8CCCDD673D
#+BEGIN_SRC shell bash
printf 'Sayonara!\n' && sleep 1
#+END_SRC

* Deploy
:PROPERTIES:
:header-args: :tangle ./deploy :tangle-mode (identity #o755)
:ID:       0F3EA345-BB8F-4300-BF94-CD5FCBA7B43F
:END:

- Deploy using symbolic link clobbering

#+NAME: 6B840488-783C-4290-9133-7E4209247FB3
#+BEGIN_SRC shell bash
function bash_deploy() {
    ln -s -f ${PWD}/.bash_profile ~/.bash_profile
    ln -s -f ${PWD}/.bash_logout ~/.bash_logout
    ln -s -f ${PWD}/.bashrc ~/.bashrc
}

bash_deploy
#+END_SRC

#  LocalWords:  expressivity
