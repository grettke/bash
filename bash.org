* Research, Goals, & Beginnings
** Desire

- High-quality box provisioning
- Advanced =bash= knowledge
  - Have less than basic knowledge
- Recognition of =bash= as a first-class programming language

** Satisfaction

- Search for learning resources
  - Googled "advanced bash", went through first two pages of results and
    selected "interesting" resources
    - [[http://www.tldp.org/LDP/abs/html/][Advanced Bash-Scripting Guide]] <2014-03-14 Fri>
      - Comprehensive nice looking contents
    - [[https://www.gnu.org/software/bash/manual/][Bourne-Again SHell manual <2015-01-19 Mon> ]]
      - The user manual
    - [[http://wiki.bash-hackers.org/scripting/tutoriallist][List of Bash online-tutorials]]
      - Ranked index of online resources
    - [[http://www.amazon.com/s/ref=sr_nr_p_n_feature_browse-b_1?fst=as%253Aoff&rh=n%253A283155%252Ck%253ABash+Scripting%252Cp_n_feature_browse-bin%253A618073011&keywords=Bash+Scripting&ie=UTF8&qid=1452906677&rnid=618072011][Amazon Kindle Results for "Bash Scripting"]], 29 results, only chose ones
      that were novel or 2015+
    - Days later revised my search results to: Kindle, 4=stars+ on them and
       this one won with 5/5 stars of 20 reviews. I was looking for 2015
       or newest possible because I wanted Bash 4.2 covered; it added arrays.
       All years of books are probably valuable; I'm trying to save time by
       getting everything in one. Might be possible, might not; and I will try.
       The search results seem to include more than the criteria should have
       excluded.
      - 19 search results
      - Looked for: high ratings, 4 ratings, interesting title and cover
      - Interesting and pursuing
      - Interesting stuff, pursuing
        - A. [[http://smile.amazon.com/Mastering-Unix-Shell-Scripting-Administrators-ebook/dp/B004S82Q2K/ref=sr_1_12?s=books&ie=UTF8&qid=1453549654&sr=1-12&keywords=bash+scripting&refinements=p_72%253A1250221011%252Cp_n_feature_nine_browse-bin%253A3291437011%252Cp_n_feature_browse-bin%253A618073011][Mastering Unix Shell Scripting: Bash, Bourne, and Korn Shell Scripting for Programmers, System Administrators, and UNIX Gurus]]
          - Totally wowed by the reviews
          - Pragmatic case studies, no theory, all practice; wow
        - B. [[http://smile.amazon.com/Linux-Command-Shell-Scripting-Bible-ebook/dp/B00RZDNL5Q/ref=sr_1_4?s=books&ie=UTF8&qid=1453549654&sr=1-4&keywords=bash+scripting&refinements=p_72%253A1250221011%252Cp_n_feature_nine_browse-bin%253A3291437011%252Cp_n_feature_browse-bin%253A618073011][Linux Command Line and Shell Scripting Bible]]
          - Gut feeling is great
          - The perennial reference
          - Well loved
        - C. [[http://smile.amazon.com/Linux-Command-Line-Complete-Introduction-ebook/dp/B006X2QEQS/ref=sr_1_5?s=books&ie=UTF8&qid=1453549654&sr=1-5&keywords=bash+scripting&refinements=p_72%253A1250221011%252Cp_n_feature_nine_browse-bin%253A3291437011%252Cp_n_feature_browse-bin%253A618073011][The Linux Command Line: A Complete Introduction]]
          - 230/4.5. Looks great.
          - Good for beginners; I'm kind of a beginner wouldn't hurt to cover
            the stuff
        - D. [[http://www.amazon.com/Unix-Power-Tools-Shelley-Powers-ebook/dp/B0043EWUT8/ref=sr_1_fkmr1_1?s=books&ie=UTF8&qid=1453570490&sr=8-1-fkmr1&keywords=unix+scripting+pro+100][Unix Power Tools]]
          - Addictive, almanac, desert island, holy grail
          - Primarily for advanced users
        - E. [[http://www.amazon.com/Unix-Linux-System-Administration-Handbook-ebook/dp/B003YMNVCA/ref=pd_sim_351_2?ie=UTF8&dpID=61Wji3cvETL&dpSrc=sims&preST=_AC_UL160_SR123%252C160_&refRID=1MCP0FZHMWM62X5A02T7][Unix and Linux System Administration Handbook]]
          - Classic, wow
      - That got me thinking about asking the question
        - Do I want to learn Bash well? Do I want to learn scripting and system
          administration well? First, I want to learn Bash well, so I will focus
          on a Bash scripting book. This is for system admnistration in the form
          of DevOps, so I will pursue it in that order.
        - Is this realistic or possible? Starting to narrow it down. Thus far
          I've only read review and the title/cover. Reading the blurbs now.
          - +A :: real world, perfect.
          - +D :: mentions zsh, security, and more, didn't want a reference now,
               and this seems to have everything
          - +E :: Doesn't bloviate, all aspects, wow
          - -B :: seems like a great reference/introduction (refintroduction?)
               and not something I want given I want Bash stuff this also seems
               too introductory
          - -C :: mention Vi and deleting files, too basic
        - Down to 3: A, D, E
          - Only want one. Need to scope this somehow.
          - Never conidered how much I suck at sysadmin'ing, yikes I mean I can
            make it happen, not too badly, but I never read a single document
            on "being a sysadmin. Maybe it doesn't matter?
          - E is out, for the future, scope just too big
        - Down to 2: A, E
          - Review again
            - D :: Sysadmin stuff. Same as devops.
            - A :: says all the right things, develop a GUI with bash, but doesn't
                 get to Shell scripting until part 2 in chapter *11*, signal
                 handling is nice never touched that, advanced scipting doesn't
                 seem that advanced. Book has tone of sysadmin stuff, or if you
                 never used UNIX before. 3 chapters of example scripts that is
                 cool. First half of the book might skip.
          - Thoughts
            - Both are great books for different reasons
            - Perhaps I should get both?
            - Reviewed the TOCs again remembering the goal
              - A - Ch 1: overview. Everything else examples. Expect, can I use
                expect to answer prompts for stuff? I should learn Expect. Might
                not even need something like Monit if it is this simple. Sweet,
                sweet stuff.
              - B - Lookg introductory, but not, all useful stuff, might upt
                documentation together in mind
              - C - basics
              - D - shouldl ike it, but don't
                E - awesome, too much
            - Thoughts
              - Screwed up lettering, that was a bad idea
              - Both A and B look good, B leans more towards an overview thing,
                which is what I wanted in addition to the reference manual.
                I'll start there, bought it.

** Decision

- Read the user manual
  - It exists for a reason
- Read one other resource
  - Provides another perspective, and voice
  - Balance speed with detail

* Making Sense of this Script
:PROPERTIES:
:ID:       886036D5-3715-492B-9ABF-825F4058A995
:END:

** Desires
:PROPERTIES:
:ID:       C1CA8CCE-D299-4034-8ACA-432622B38640
:END:

- Things that I want to do with Bash, and how I want to do them
  - Understand the computer and its operating system
    - Explore the contents of the disk drive and memory
  - Automated tedious and error prone tasks as quickly as possible
    - Develop shell scripts to do so
    - Leverage multi-tasking
  - Maximize expressivity and predictability
    - Maximize predictability
    - Minimize surprise
    - Fail fast

** Approach to Learning and Configuring Bash
:PROPERTIES:
:ID:       9C4ED82B-B909-4546-9AA4-EC1877223C8D
:END:

- Bash provides a rich and complicated configuration facility
- Successfully solving problems with Bash requires that you (goal)
  - Understand what it can do
  - Configure it to do so in a way that you prefer
- Working with Bash provides the results by recognizing that you attain practice
  and experience (means)
  - Understanding possibilities requires study and practice (practice)
  - Configuring requires experience and personal-preference (experience)
- The purpose of this document is to capture both the means and the goal

** The Purpose of Bash
:PROPERTIES:
:ID:       20275946-BE34-4DC6-B9B1-A5944F23B899
:END:

- The ~set~ builtin
  [fn:1c25a9a2ecf21a00:https://www.gnu.org/software/bash/manual/html_node/The-Set-Builtin.html]
  onerously states that "This builtin is so complicated that it deserves its own
  section". That can be off-putting for the new-operator (or programmer). The
  word /complicated/ is more like a code-word here though; it is really a short
  hand for /expressivity/. ~set~ lets you configure the system (Bash) any way you
  choose; it fully enables you to express your personal definition of
  expressivity when it comes to system management. This is no small feat. Doing
  so belies the complexity, magnitude, and power lurking behind the thin veneer
  that most only know as "the powerful command line interface" that most only
  use to start graphical user interface applications. Bash is the most humble
  servant; expertly negotiation with the kernel, humbly taking orders from the
  operator, and deftly managing the work of any number of processes.
  Forgive my anthropomorphization; we may ever know someone like Bash in our own
  lives for that is truly a rare and kind soul.

** Understanding Your Cognitive Landscape
:PROPERTIES:
:ID:       435374DD-FDEA-4D0A-B5C2-5E205B30B04F
:END:

- Doing things with Bash
  - It is difficult to make sense of all of the configuration options for doing
    things with Bash
  - When you've got experience, rely on that
  - When you haven't got experience, document your intent and obtain experience
  - Both the things that you do with Bash and the thing that you /want to/ do with
    Bash are your personal cognitive landscape that guide the configuration
- Roles of Doers
  - My goal is to classify configuration options by roles that have different
    goals. Some of the roles have overlap in the goals, some don't. I don't
    know yet what are the best role definitions or how options overlap. I will
    find out and document it here. /Doers/ is the name of someone or something
    executing things with an intent. My goal is to reveal intent and use that
    for classification and role definition.
  - Broad Doer definitions
    - Interactive vs Non-Interactive Shell
      - Interactive: requires input from the user
      - Non-Interactive: doesn't
      - Unsure how to use this to classify configuration because most scripts
        are in a =tty= and you /can/ accept input. Should you? Is that the question?
        What does it mean to configure Bash, and for what? Here is an attempt:
        - Interactive is for configuring things that you only ever want to do
          or care about as a human sitting at a terminal. These are things that
          I will pretend/decide that I will never every do when running a
          non-interactive script. This whole plan relies on strictly separating
          implementation of both kinds of scripts
        - Non-interactive is for things that I as a human will never see. Or
          perhaps things that I don't care to see immediately because I didn't
          run them. The overlap is so close here. Perhaps "things that I want
          to see" and "things that I want to do interactively" is the correct
          classifier.
        - This is a design choice
    - Login and Non-Login Shell
      - Are you initiating things or is a ~cron~?
      - This is a system/user choice
        - You choose to use the system; executing things via a Login shell
        - You schedule things for the system to do; executing things via a
          Non-Login shell
- Classifying things Bash can do
  - Not using tags to classify because they won't reflect document structure and
    I'm not sure where to begin
  - Tried using multiple tags and that confused the whole effort
  - Switched to one tag
    - Every time I feel like using multiple tags, I will try to update the
      Desires to make sense of what I value

** Observations & Questions & Decisions
:PROPERTIES:
:ID:       3D8CB422-87BC-47A8-BA42-8D4A0AFEF99E
:END:

*** Version 1
:PROPERTIES:
:ID:       F1878DC4-317A-4743-90D0-DFF6971E58FB
:END:

- The login interactive shell is for things that you will only do at the
  start and finish of a logical session
  - Attached to your ID and a ~tty~ owned by you
  - Not much work to do here
- The login non-interactive shell is for things that you will do every time
  that you begin another shell during a logical session
  - This includes the login interactive shell, execute this as suggested by
    the Bash reference manual
- The non-login non-interactive shell
  - Is non-interactive because you have no way of interacting with it unless
    you hack some way to do so
  - Non-Interactive is somewhat a misnomer here because you can choose to
    implement non-interactive scripts when a ~tty~ is attached but when you
    haven't got a ~tty~ attached there is no possibility of running interactive
    scripts
  - Is non-login because it is not associated with your ID and at the same
    time not attached to a ~tty~ attached to you
  - This document won't address non-login shells
    - If you develop your scripts in a richly configured Bash environment, you
      will have to configure non-login shells to use the same environment. I am
      avoiding this topic because I need to see where this experiment goes.
    - That was a mistake. After developing a powerful Bash environment you are
      likely to want to use that same environment for non-login shells. Of
      course you are!

*** Version 2
:PROPERTIES:
:ID:       E1339F20-FAF2-4E46-AFF1-DCB5811F80BE
:END:

- Configure Bash for every user?
  - Login Interactive and Non-Login Interactive are easy and obvious
  - Non-Login Non-Interactive seems valuable but is less obvious
- Bash vs Dash
  - Performance reasons?
  - [[https://www.wikivs.com/wiki/Bash_vs_dash][Via]]
    #+BEGIN_QUOTE
     Dash (Debian Almquist SHell) is a shell that has poor usability by modern standards when used as an interactive log-in shell, but is faster in executing POSIX-compliant scripts than Bash.
     Bash (Bourne Again SHell) has many more features and is especially preferable when used interactively (although it does contain more programming features too).
     Bash is typically provided as the default interactive shell, while Debian and Debian-derivatives like Ubuntu provide Dash as the /bin/sh implementation, thereby causing scripts with #!/bin/sh shebangs to be interpreted by Dash rather than Bash by default. For scripts that require Bash for execution, Bash will still be used as the interpreter if the shebang is #!/bin/bash.
     Bash is designed for human beings and provides a superset of POSIX functionality
     Supports the same scripting commands as Dash as well as its own additional commands (sometimes called "Bashisms")
     Supports tab completion
     Supports a command history
     Dash is for non-interactive script execution
     Only supports POSIX compliant features
     Small binary size (Dash is only 100K compared to Bash's 900K)
     Faster start-up and script execution
     #+END_QUOTE
    - This provokes more questions
      - Why have programming expressivity for DevOps and System Administration
        if you can't or shouldn't use it for startup scripts?
- [[http://lkhill.com/binsh-checking-for-bash-vs-dash-incompatibilities/][Just call Bash explicitly; it is not an issue]]
- [[http://shebang.brandonmintern.com/bourne-is-not-bash-or-read-echo-and-backslash/][Important differences between Bourne and POSIX compliant shells]]
  - POSIX for speed
  - Bash better for scripting
  - Call it for the user with =#!/usr/bin/env bash=
- Bash is for interactive tasks; Dash is for non-interactive tasks
- You don't need Readline in non-interactive mode

*** Version 3
:PROPERTIES:
:ID:       DDB77782-98C3-4F45-9CCA-3D17CBAC327F
:END:

- Desires read like
  - Things that you would do as a software engineer
  - Things that you would do as a devops engineer
- Desire don't read like
  - Things that you would do as scheduled task
  - Things that you would do as a remotely executed task
- This looks like a Bash system that
  - Configures Bash for login shells and nothing more
- Because
  - Any further scope has no desires or experience to guide it
    - Attempting to do anything more would result in aimless fruitless wandering

* Configuration
:PROPERTIES:
:ID:       A1DF7D9E-5B52-46D6-90CB-FC43C50D5E41
:END:

- Bash Startup Behavior [fn:49d34ab293ff88f:https://www.gnu.org/software/bash/manual/html_node/Bash-Startup-Files.html#Bash-Startup-Files]
- Bourne Variables [fn:105ae6c2bd4f43c8:https://www.gnu.org/software/bash/manual/html_node/Bourne-Shell-Variables.html#Bourne-Shell-Variables]
- Bash Variables [fn:7b4f219d43d6ef2:https://www.gnu.org/software/bash/manual/html_node/Bash-Variables.html#Bash-Variables]

** Interactive Non-Login
:PROPERTIES:
:header-args: :tangle ./.bashrc
:ID:       30F7B093-5CC8-4545-A30E-C9D025AC7265
:END:

**** Options
:PROPERTIES:
:ID:       353A8149-9AE8-41A8-878D-22D5141C1AA9
:END:

***** Set
:PROPERTIES:
:ID:       304CD69B-9D22-4E27-8566-2223E340AF37
:END:

- Environment
  - Child shells inherit *every* function and variable created or modified
    #+NAME: ACD7221D-802A-4999-AF10-E0E43E98DB17
    #+BEGIN_SRC shell bash
set -o allexport
    #+END_SRC
- Evaluation
  - Perform brace expansion
    #+NAME: 159E2F76-E2E4-4D77-869C-9B1173E10036
    #+BEGIN_SRC shell bash
set -o braceexpand
    #+END_SRC
- Interaction

***** Shopt
:PROPERTIES:
:ID:       A6298426-7595-4D20-8214-FF28A0534F9F
:END:

**** Variables
:PROPERTIES:
:ID:       3773C1C1-F98E-4B95-8067-715796A83686
:END:

Provide just enough information at the prompt to be useful without cluttering
up the terminal. Escaping not required.

#+NAME: 2EF3117A-BB20-475A-9970-14C361F3687F
#+BEGIN_SRC shell bash
PS1='\u@\h:\w> '
#+END_SRC

Make the continued prompt obvious. Escaping not required.

#+NAME: 07689AC5-8AC7-4B3E-88ED-BC7CA747BB35
#+BEGIN_SRC shell bash
PS2='↪> '
#+END_SRC

**** Functions
:PROPERTIES:
:ID:       C61DCCE0-1782-4511-BA40-E84B8A12C566
:END:

** Interactive Login
:PROPERTIES:
:ID:       2476DE76-A6CB-4834-9DEA-6A644BED0F54
:END:

*** Login
:PROPERTIES:
:header-args: :tangle ./.bash_profile
:ID:       B281581F-2E1B-4E02-9787-BE9E23DD8907
:END:

Execute the same configuration as every non-login interactive shell.

#+NAME: 5487397C-D5F5-4C24-919C-66BFAF9B9312
#+BEGIN_SRC shell bash
if [ -f ~/.bashrc ]; then . ~/.bashrc; fi
#+END_SRC

Have fun.

#+NAME: 04A53A3A-B30D-4122-8736-6F411639FE61
#+BEGIN_SRC shell bash
fortune
#+END_SRC

*** Logout
:PROPERTIES:
:header-args: :tangle ./.bash_logout
:ID:       D0503846-C5ED-4CBC-99F3-2B3DE5449FC3
:END:

Have fun.

#+NAME: E55BD1DC-42CF-4394-B2C1-5D8CCCDD673D
#+BEGIN_SRC shell bash
printf 'Sayonara!\n' && sleep 1
#+END_SRC

* Deployment
:PROPERTIES:
:header-args: :tangle ./deploy :tangle-mode (identity #o755)
:ID:       0F3EA345-BB8F-4300-BF94-CD5FCBA7B43F
:END:

- Deploy using symbolic linking

#+NAME: 6B840488-783C-4290-9133-7E4209247FB3
#+BEGIN_SRC shell bash
function bash_deploy() {
    ln -s -f ${PWD}/.bash_profile ~/.bash_profile
    ln -s -f ${PWD}/.bash_logout ~/.bash_logout
    ln -s -f ${PWD}/.bashrc ~/.bashrc
}

bash_deploy
#+END_SRC

#  LocalWords:  expressivity
